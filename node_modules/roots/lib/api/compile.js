// Generated by CoffeeScript 1.7.0
(function() {
  var Compile, Compiler, FSParser, W, fs, guard, keys, mkdirp, nodefn, sequence;

  fs = require('fs');

  W = require('when');

  nodefn = require('when/node');

  guard = require('when/guard');

  keys = require('when/keys');

  sequence = require('when/sequence');

  mkdirp = require('mkdirp');

  FSParser = require('../fs_parser');

  Compiler = require('../compiler');


  /**
   * @class Compile
   * @classdesc Compiles a project
   */

  Compile = (function() {

    /**
     * Creates a new instance of the compile class.
     * 
     * - makes a new fs parser instance
     * - makes a new compiler instance
     * - makes a new instance of each extension, with error detection.
     *   this must happen every compile pass to clear lingering context
     * 
     * @param  {Function} roots - instance of the base roots class
     */
    var after_hook, before_hook, create_folders, hook_method, process_files, purge_empty_folders;

    function Compile(roots) {
      this.roots = roots;
      this.extensions = this.roots.extensions.instantiate();
      this.fs_parser = new FSParser(this.roots, this.extensions);
      this.compiler = new Compiler(this.roots, this.extensions);
    }


    /**
     * Compiles the project. This process includes the following steps:
     *
     * - execute user before hooks if present
     * - parse the project, sort files into categories
     * - create the folder structure
     * - compile and write each of the files
     * - execute user after hooks if present
     * - removes any empty folders that exist after compile
     * - emit finished events
     */

    Compile.prototype.exec = function() {
      this.roots.emit('start');
      return before_hook.call(this).then(this.fs_parser.parse.bind(this.fs_parser))["with"](this).tap(create_folders).then(process_files).then(after_hook).then(purge_empty_folders).done(((function(_this) {
        return function() {
          return _this.roots.emit('done');
        };
      })(this)), ((function(_this) {
        return function(err) {
          return _this.roots.emit('error', err);
        };
      })(this)));
    };


    /**
     * Calls any user-provided before hooks with the roots context.
     *
     * @private
     */

    before_hook = function() {
      return hook_method.call(this, this.roots.config.before);
    };


    /**
     * Calls any user-provided after hooks with the roots context.
     *
     * @private
     */

    after_hook = function(ast) {
      return hook_method.call(this, this.roots.config.after);
    };


    /**
     * Checks to ensure the requested hook(s) is/are present, then calls them,
     * whether there was an array of hooks provided or just a single hook.
     *
     * @private
     * 
     * @param  {Array|Function} hook - a function or array of functions
     * @return {Promise} promise for resolved hooks
     */

    hook_method = function(hook) {
      var hooks;
      if (!hook) {
        return W.resolve();
      }
      if (Array.isArray(hook)) {
        hooks = hook.map((function(_this) {
          return function(h) {
            return nodefn.call(h.bind(_this.roots));
          };
        })(this));
      } else if (typeof hook === 'function') {
        hooks = [nodefn.call(hook.bind(this.roots))];
      } else {
        return W.reject('before hook should be a function or array');
      }
      return W.all(hooks);
    };


    /**
     * Creates the nested folder structure for a project. First, creates an array
     * of just the output paths, then creates the base public folder, then
     * sequentially walks through the folders and creates them all.
     * 
     * @param  {Object} ast - roots ast
     */

    create_folders = function(ast) {
      var output_paths;
      output_paths = ast.dirs.map((function(_this) {
        return function(d) {
          return _this.roots.config.out(d);
        };
      })(this));
      this.__dirs = output_paths;
      return nodefn.call(mkdirp, this.roots.config.output_path()).then(function() {
        return W.map(output_paths, guard(guard.n(1), nodefn.lift(mkdirp)));
      });
    };


    /**
     * Files are processed by category, and each category can be processed in
     * One of two ways: parallel or ordered. Parallel processed categories will
     * crunch through their files as quickly as possible, starting immediately.
     * Ordered categories will parallel compile all the files in the category, but
     * wait until one category is finished before moving to the next one.
     *
     * An example use for each of these is client templates and dynamic content.
     * With client templates, they do not depend on any other compile process so
     * they are a great fit for parallel. For dynamic content, the front matter must
     * be parsed then available in normal templates, which means all dynamic content
     * must be finished parsing before normal content starts. For this reason, dynamic
     * content has to be ordered so it is placed before the normal compiles.
     *
     * So what this function does is first distinguishes ordered or parallel for each
     * extension, then pushes a compile task for that extension onto the appropriate
     * stack. The compile task just grabs the files from the category and runs them
     * each through the compiler's `compile` method. Then when they are finished, it
     * runs the after category hook.
     *
     * Once the ordered and parallel stacks are full of tasks, they are run. Ordered
     * gets sequenced so they run in order, and parallel runs (surprise) in parallel.
     * 
     * @param  {Object} ast - roots ast
     */

    process_files = function(ast) {
      var category, compile_task, ext, extfs, ordered, parallel, _i, _len, _ref;
      ordered = [];
      parallel = [];
      compile_task = (function(_this) {
        return function(category) {
          return W.map(ast[category] || [], _this.compiler.compile.bind(_this.compiler, category)).then(function() {
            return sequence(_this.extensions.hooks('category_hooks.after', category), _this, category);
          });
        };
      })(this);
      _ref = this.extensions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ext = _ref[_i];
        extfs = ext.fs ? ext.fs() : {};
        category = extfs.category ? extfs.category : ext.category;
        if (typeof extfs !== 'object') {
          this.roots.bail(125, 'fs must return an object', ext);
        }
        if (Object.keys(extfs).length > 0 && !extfs.category && !category) {
          this.roots.bail(125, 'fs hooks defined with no category', ext);
        }
        if (extfs.ordered) {
          ordered.push(((function(_this) {
            return function(c) {
              return compile_task.bind(_this, c);
            };
          })(this))(category));
        } else {
          parallel.push(compile_task.call(this, category));
        }
      }
      return keys.all({
        ordered: sequence(ordered),
        parallel: W.all(parallel)
      });
    };


    /**
     * Sometimes extensions prevent file writes and leave behind empty
     * folders. The client templates extension is a good example. No matter
     * how it happens, there should not be any empty folders in the output,
     * so this method gets rid of them if they exist.
     *
     * The way this is done is *very* hacky, but it is the speediest way. It
     * tries to delete every folder, and if it succeeds, it means the folder was
     * empty, as trying to remove a directory with contents throws an error (which
     * we ignore using an empty callback).
     * 
     * @private
     */

    purge_empty_folders = function() {
      return this.__dirs.map(function(d) {
        return fs.rmdir(d, function() {});
      });
    };

    return Compile;

  })();

  module.exports = Compile;

}).call(this);
